# Тема №9. Концепции и принципы ООП

Отчет по Теме №9 выполнил:

- Голосов Михаил Кириллович
  
- ОЗИВТ-22-1-у
  
| Задание | Лаб_Раб | Сам_раб |
| ------ | ------ | ------ |
| Задание 1 | + | + |
| Задание 2 | + |   |
| Задание 3 | + |   |
| Задание 4 | + |   |
| Задание 5 | + |   |

знак "+" - задание выполнено; знак "-" - задание не выполнено;

Работу проверили:

- к.э.н, доцент Панов М.А

# Лабороторная работа№1
### Допустим, что вы решили оригинально и немного странно познакомится с человеком. Для этого у вас должен быть написан свой класс на Python, который будет проверять угадал ваше имя человек или нет. Для этого создайте класс, указав в свойствах только имя. Дальше создайте функцию __init__(), а в ней сделайте проверку на то угадал человек ваше имя или нет. Также можете проверить что будет, если в этой функции указав атрибут, который не указан в вашем классе, например, попробуйте вызвать фамилию.
```python
class NameGuesser:
    def __init__(self, guessed_name):
        self.name = "Михаил"  # Укажите ваше имя здесь

        if guessed_name == self.name:
            print("Вы угадали мое имя!")
        else:
            print("Попробуйте еще раз, это не мое имя.")

            try:
                # Попытка вызвать атрибут фамилии, которого нет в классе
                print("Моя фамилия:", self.surname)
            except AttributeError as e:
                print(f"Ошибка: {e}. У класса нет атрибута 'surname'.")

# Создаем экземпляр класса, передавая введенное имя
guesser = NameGuesser(guessed_name=input("Введите имя: "))
```
### Результат
![Меню](https://github.com/Dardners/python-programming/blob/main/picture/Theme_9-1.png)
## Выводы
1. class NameGuesser: - объявление класса NameGuesser.
2. def __init__(self, guessed_name): - конструктор класса, принимающий введенное имя.
3. self.name = "Ваше_имя" - установка вашего имени в атрибут name. Здесь нужно заменить "Ваше_имя" на своё имя.
4. if guessed_name == self.name: - проверка, совпадает ли введенное имя с вашим.
5. print("Вы угадали мое имя!") - вывод сообщения, если имя угадано.
6. else: - в случае неправильного угадывания.
7. print("Попробуйте еще раз, это не мое имя.") - вывод призыва к повторной попытке.
8. try: - начало блока, в котором выполняется проверка атрибута фамилии.
9. print("Моя фамилия:", self.surname) - попытка вызвать атрибут фамилии, которого нет в классе.
10. except AttributeError as e: - обработка ошибки, если атрибута фамилии нет.
11. print(f"Ошибка: {e}. У класса нет атрибута 'surname'.") - вывод сообщения об ошибке.
12. guesser = NameGuesser(guessed_name=input("Введите имя: ")) - создание экземпляра класса NameGuesser и передача введенного имени в конструктор.

# Лабороторная работа№2
### Вам дали важное задание, написать продавцу мороженого программу, которая будет писать добавили ли топпинг в мороженое и цену после возможного изменения. Для этого вам нужно написать класс, в котором будет определяться изменили ли состав мороженого или нет. В этом классе реализуйте метод, выводящий на печать «Мороженое с {ТОППИНГ}» в случае наличия добавки, а иначе отобразится следующая фраза: «Обычное мороженое». При этом программа должна воспринимать как топпинг только атрибуты типа string.
```python
class IceCream:
    def __init__(self):
        self.toppings = set()

    def add_topping(self, topping):
        if isinstance(topping, str):
            self.toppings.add(topping)
            print(f"Мороженое с {topping}")
        else:
            print("Ошибка: Топпинг должен быть строкой.")

    def print_ice_cream(self):
        if self.toppings:
            print("Мороженое с", ", ".join(self.toppings))
        else:
            print("Обычное мороженое")

# Создаем экземпляр класса
ice_cream = IceCream()

# Добавляем топпинги
ice_cream.add_topping("шоколадный соус")
ice_cream.add_topping("орехи")
ice_cream.add_topping(42)  # Попытка добавить топпинг неправильного типа

# Выводим информацию о мороженом
ice_cream.print_ice_cream()
```
### Результат
![Меню](https://github.com/Dardners/python-programming/blob/main/picture/Theme_9-2.png)
## Выводы
1. class IceCream: - объявление класса IceCream.
2. def __init__(self): - конструктор класса, инициализирующий пустой набор (set) для топпингов.
3. self.toppings = set() - создание атрибута toppings для хранения топпингов.
4. def add_topping(self, topping): - метод для добавления топпинга в мороженое.
5. if isinstance(topping, str): - проверка, является ли топпинг строкой.
6. self.toppings.add(topping) - добавление топпинга в набор.
7. print(f"Мороженое с {topping}") - вывод сообщения о добавлении топпинга.
8. else: - в случае, если топпинг не является строкой.
9. print("Ошибка: Топпинг должен быть строкой.") - вывод сообщения об ошибке.
10. def print_ice_cream(self): - метод для вывода информации о мороженом.
11. if self.toppings: - проверка, есть ли топпинги в мороженом.
12. print("Мороженое с", ", ".join(self.toppings)) - вывод сообщения с перечислением топпингов.
13. else: - в случае отсутствия топпингов.
14. print("Обычное мороженое") - вывод сообщения о том, что мороженое обычное.
15. ice_cream.print_ice_cream() - вывод информации о мороженом.

# Лабороторная работа№3
### Петя – начинающий программист и на занятиях ему сказали реализовать икапсу…что-то. А вы хороший друг Пети и ко всему прочему прекрасно знаете, что икапсу…что-то – это инкапсуляция, поэтому решаете помочь вашему другу с написанием класса с инкапсуляцией. Ваш класс будет не просто инкапсуляцией, а классом с сеттером, геттером и деструктором. После написания класса вам необходимо продемонстрировать что все написанные вами функции работают. 
Также вас необходимо объяснить Пете почему на скриншоте ниже в консоли выводится ошибка. 
```python
class EncapsulationDemo:
    def __init__(self, private_data):
        self._data = private_data  # Префикс "_" указывает на защищенный атрибут

    def get_data(self):
        return self._data  # Геттер для получения значения атрибута

    def set_data(self, new_data):
        self._data = new_data  # Сеттер для изменения значения атрибута

    def __del__(self):
        print(f"Объект с данными {self._data} уничтожен")  # Деструктор

# Создаем экземпляр класса
demo_instance = EncapsulationDemo(private_data="Секретные данные")

# Получаем значение атрибута с помощью геттера
print(f"Исходные данные: {demo_instance.get_data()}")

# Изменяем значение атрибута с помощью сеттера
demo_instance.set_data("Новые секреты")

# Снова получаем значение атрибута
print(f"Обновленные данные: {demo_instance.get_data()}")

# Уничтожаем объект с данными при завершении программы
del demo_instance

# Пример ошибки при доступе к закрытому атрибуту
try:
    print(demo_instance._data)
except AttributeError as e:
    print(f"Ошибка: {e}")
```
### Результат
![Меню](https://github.com/Dardners/python-programming/blob/main/picture/Theme_9-3.png)
## Выводы
1. class EncapsulationDemo: - объявление класса EncapsulationDemo.
2. def __init__(self, private_data): - конструктор класса, инициализация защищенного атрибута _data.
3. self._data = private_data - установка значения защищенного атрибута.
4. def get_data(self): - метод-геттер для получения значения атрибута.
5. return self._data - возвращение значения атрибута из геттера.
6. def set_data(self, new_data): - метод-сеттер для изменения значения атрибута.
7. self._data = new_data - изменение значения атрибута из сеттера.
8. def __del__(self): - деструктор класса.
9. print(f"Объект с данными {self._data} уничтожен") - вывод сообщения при уничтожении объекта.
10. demo_instance = EncapsulationDemo(private_data="Секретные данные") - создание экземпляра класса.
11. print(f"Исходные данные: {demo_instance.get_data()}") - вывод исходных данных с использованием геттера.
12. demo_instance.set_data("Новые секреты") - изменение данных с использованием сеттера.
13. print(f"Обновленные данные: {demo_instance.get_data()}") - вывод обновленных данных с использованием геттера.
14. del demo_instance - уничтожение объекта, вызывается деструктор.
21-24. Попытка доступа к закрытому атрибуту _data после удаления объекта, что вызовет ошибку AttributeError.

# Лабороторная работа№4
### Вам	прекрасно	известно,	что	кошки	и	собаки	являются млекопитающими, но компьютер этого не понимает, поэтому вам нужно написать три класса: Кошки, Собаки, Млекопитающие. И при помощи “наследования” объяснить компьютеру что кошки и собаки – это млекопитающие. Также добавьте какой-нибудь свой атрибут для кошек и собак, чтобы показать, что они чем-то отличаются друг от друга. 
```python
class Mammal:
    def __init__(self):
        self.is_mammal = True  # Общий атрибут для всех млекопитающих

class Cat(Mammal):
    def __init__(self, breed):
        super().__init__()
        self.breed = breed  # Атрибут для кошек
        self.sound = "Мяу"  # Дополнительный атрибут для кошек

class Dog(Mammal):
    def __init__(self, breed):
        super().__init__()
        self.breed = breed  # Атрибут для собак
        self.sound = "Гав"  # Дополнительный атрибут для собак
```
### Результат
![Меню](https://github.com/Dardners/python-programming/blob/main/picture/Theme_9-4.png)
## Выводы
1. class Mammal: - объявление базового класса Mammal (Млекопитающие).
2. def __init__(self): - конструктор класса Mammal.
3. self.is_mammal = True - установка атрибута is_mammal в True для всех млекопитающих.
4. class Cat(Mammal): - объявление класса Cat (Кошки), который наследуется от класса Mammal.
5. def __init__(self, breed): - конструктор класса Cat.
6. super().__init__() - вызов конструктора родительского класса для установки общего атрибута is_mammal.
7. self.breed = breed - установка атрибута breed для кошек.
8. self.sound = "Мяу" - установка дополнительного атрибута sound для кошек.
9. class Dog(Mammal): - объявление класса Dog (Собаки), который также наследуется от класса Mammal.
10. def __init__(self, breed): - конструктор класса Dog.
11. super().__init__() - вызов конструктора родительского класса для установки общего атрибута is_mammal.
12. self.breed = breed - установка атрибута breed для собак.
13. self.sound = "Гав" - установка дополнительного атрибута sound для собак.

# Лабороторная работа№5
### На разных языках здороваются по-разному, но суть остается одинаковой, люди друг с другом здороваются. Давайте вместе с вами реализуем программу с полиморфизмом, которая будет описывать всю суть первого предложения задачи. Для этого мы можем выбрать два языка, например, русский и английский и написать для них отдельные классы, в которых будет в виде атрибута слово, которым здороваются на этих языках. А также напишем функцию, которая будет выводить информацию о том, как на этих языках здороваются. Заметьте, что для решения поставленной декоратор @staticmethod, поскольку нам параметры-ссылки вроде self. 
```python
class RussianLanguage:
    greeting_word = "Привет"

    @staticmethod
    def greet():
        print("На русском: " + RussianLanguage.greeting_word)


class EnglishLanguage:
    greeting_word = "Hello"

    @staticmethod
    def greet():
        print("In English: " + EnglishLanguage.greeting_word)


def show_greetings(language):
    language.greet()

# Создаем экземпляры классов
russian = RussianLanguage()
english = EnglishLanguage()

# Выводим приветствия на обоих языках с использованием полиморфизма
show_greetings(russian)
show_greetings(english)

```
### Результат
![Меню](https://github.com/Dardners/python-programming/blob/main/picture/Theme_9-5.png)
## Выводы
1. class RussianLanguage: - объявление класса для русского языка.
2. greeting_word = "Привет" - атрибут класса с приветствием на русском.
3. @staticmethod - декоратор для объявления статического метода, который не требует доступа к экземпляру класса.
4. def greet(): - объявление статического метода greet для вывода приветствия на русском.
5. class EnglishLanguage: - объявление класса для английского языка.
6. greeting_word = "Hello" - атрибут класса с приветствием на английском.
7. @staticmethod - декоратор для объявления статического метода greet для вывода приветствия на английском.
8. def show_greetings(language): - объявление функции для отображения приветствия на заданном языке.
9. language.greet() - вызов статического метода greet для переданного языка.

# Самостоятельная работа№1
### Задание Садовник и помидоры. 
Классовая структура: 
Текстовое полеЕсть Помидор со следующими характеристиками: 
· Индекс 
· Стадия созревания (стадии: отсутствует, цветение, зеленый, красный) 
Помидор может: 
· Расти (переходить на следующую стадию созревания) · Предоставлять информацию о своей зрелости 
Есть Куст с помидорами, который: 
· Содержит список томатов, которые на нем растут 
А также может: 
· Расти вместе с томатами 
· Предоставлять информацию о зрелости всех томатов · Предоставлять урожай 
И также есть Садовник, который имеет: 
· Имя 
· Растение, за которым он ухаживает 
Он может: 
· Ухаживать за растением · Собирать с него урожай 
Задание: 
Класс Tomato: 

1) Создайте класс Tomato 

2) Создайте статическое свойство states, которое будет содержать все стадии созревания помидора 

3) Создайте метод __init__(), внутри которого будут определены два динамических свойства: _index (передается параметром) и _state 
(принимает первое значение из словаря states). После написания этого блока кода в комментарии к нему укажите какими являются эти два свойства 

4) Создайте метод grow(), который будет переводить томат на следующую стадию созревания 

5) Создайте метод is_ripe(), который будет проверять, что томат созрел 
Текстовое полеКласс TomatoBush: 

1) Создайте класс TomatoBush 

2) Определите метод __init__(), который будет принимать в качестве параметра количество томатов и на его основе будет создавать список объектов класса Tomato. Данный список будет храниться внутри динамического свойства tomatoes 

3) Создайте метод grow_all(), который будет переводить все объекты из списка томатов на следующий этап созревания 

4) Создайте метод all_are_ripe(), который будет возвращать True, если все томаты из списка стали спелыми. 

5) Создайте метод give_away_all(), который будет чистить список томатов после сбора урожая 
Класс Gardener: 

1) Создайте класс Gardener 

2) Создайте метод __init__(), внутри которого будут определены два динамических свойства: name (передается параметром, является публичным) и _plant (принимает объект класса TomatoBush). После написания этого блока кода в комментарии к нему укажите какими являются эти два свойства 

3) Создайте метод work(), который заставляет садовника работать, что позволяет растению становиться более зрелым 

4) Создайте метод harvest(), который проверяет, все ли плоды созрели. Если все, то садовник собирает урожай. Если нет, то метод печатает предупреждение 

5) Создайте статический метод knowledge_base(), который выведет в консоль справку по садоводству 
Тесты: 

1) Вызовите справку по садоводству 

2) Создайте объекты классов TomatoBush и Gardener 

3) Используя объект класса Gardener, поухаживайте за кустом с помидорами 

4) Попробуйте собрать урожай, когда томаты еще не дозрели. Продолжайте ухаживать за ними 

5) Соберите урожай 
Результатом работы вашей программы будет листинг кода с подробными комментариями и скриншоты выполенния всех тестов. 
```python
class Tomato:
    states = ["отсутствует", "цветение", "зеленый", "красный"]

    def __init__(self, index):
        self._index = index  # Динамическое свойство, индекс помидора
        self._state = self.states[0]  # Динамическое свойство, начальная стадия созревания (отсутствует)

    def grow(self):
        if self._state != self.states[-1]:
            current_state_index = self.states.index(self._state)
            self._state = self.states[current_state_index + 1]

    def is_ripe(self):
        return self._state == self.states[-1]

class TomatoBush:
    def __init__(self, num_tomatoes):
        self.tomatoes = [Tomato(index) for index in range(1, num_tomatoes + 1)]

    def grow_all(self):
        for tomato in self.tomatoes:
            tomato.grow()

    def all_are_ripe(self):
        return all(tomato.is_ripe() for tomato in self.tomatoes)

    def give_away_all(self):
        self.tomatoes = []

class Gardener:
    def __init__(self, name, plant):
        self.name = name  # Динамическое свойство, имя садовника (публичное)
        self._plant = plant  # Динамическое свойство, объект класса TomatoBush

    def work(self):
        self._plant.grow_all()

    def harvest(self):
        if self._plant.all_are_ripe():
            self._plant.give_away_all()
            print("Урожай собран.")
        else:
            print("Не все томаты созрели. Продолжайте ухаживать за ними.")

    @staticmethod
    def knowledge_base():
        print("Садоводство - это искусство выращивания растений.")

# Тесты
Gardener.knowledge_base()

bush = TomatoBush(num_tomatoes=5)
gardener = Gardener(name="Вася", plant=bush)

gardener.work()
gardener.harvest()

gardener.work()
gardener.work()
gardener.harvest() 
```
### Результат
![Меню](https://github.com/Dardners/python-programming/blob/main/picture/Theme_9-6.1.png)
![Меню](https://github.com/Dardners/python-programming/blob/main/picture/Theme_9-6.2.png)
## Выводы
1. class Tomato: - объявление класса Tomato.
2. states = ["отсутствует", "цветение", "зеленый", "красный"] - статическое свойство с возможными стадиями созревания помидора.
3. def __init__(self, index): - конструктор класса Tomato с параметром index.
4. self._index = index - динамическое свойство, индекс помидора.
5. self._state = self.states[0] - динамическое свойство, начальная стадия созревания (отсутствует).
6. def grow(self): - метод для перехода к следующей стадии созревания.
7. if self._state != self.states[-1]: - проверка, не является ли текущая стадия последней (красной).
8. current_state_index = self.states.index(self._state) - получение индекса текущей стадии.
9. self._state = self.states[current_state_index + 1] - переход к следующей стадии созревания.
10. def is_ripe(self): - метод для проверки, созрел ли помидор.
11. return self._state == self.states[-1] - возвращение True, если текущая стадия созревания равна последней (красной).
12. class TomatoBush: - объявление класса TomatoBush.
13. def __init__(self, num_tomatoes): - конструктор класса TomatoBush с параметром num_tomatoes.
14. self.tomatoes = [Tomato(index) for index in range(1, num_tomatoes + 1)] - динамическое свойство, список объектов класса Tomato созданных на основе количества томатов.
15. def grow_all(self): - метод для перевода всех томатов на следующую стадию созревания.
16. for tomato in self.tomatoes: tomato.grow() - для каждого томата вызываем метод grow.
17. def all_are_ripe(self): - метод для проверки, все ли томаты спелые.
18. return all(tomato.is_ripe() for tomato in self.tomatoes) - возвращает True, если все томаты спелые.
19. def give_away_all(self): - метод для сбора урожая.
20. self.tomatoes = [] - очищает список томатов после сбора урожая.
21. class Gardener: - объявление класса Gardener.
22. def __init__(self, name, plant): - конструктор класса Gardener с параметрами name и plant.
23. self.name = name - динамическое свойство, имя садовника (публичное).
24. self._plant = plant - динамическое свойство, объект класса TomatoBush.
25. def work(self): - метод для "работы" садовника, перевода всех томатов на следующую стадию созревания.
26. self._plant.grow_all() - вызывает метод grow_all у объекта TomatoBush.
27. def harvest(self): - метод для сбора урожая.
28. if self._plant.all_are_ripe(): - проверяет, все ли томаты созрели.
29. self._plant.give_away_all() - если да, то собирает урожай.
30. print("Урожай собран.") - выводит сообщение об успешном сборе урожая.
31. else: - если не все томаты созрели.
32. print("Не все томаты созрели. Продолжайте ухаживать за ними.") - выводит предупреждение.
33. @staticmethod - декоратор для объявления статического метода.
34. def knowledge_base(): - статический метод для вывода справки по садоводству.
35. print("Садоводство - это искусство выращивания растений.") - выводит справку.
36. Gardener.knowledge_base() - Вызываем статический метод knowledge_base класса Gardener, который выводит справку по садоводству.
37. bush = TomatoBush(num_tomatoes=5) - Создаем объект класса TomatoBush с 5 томатами.
38. gardener = Gardener(name="Вася", plant=bush) - Создаем объект класса Gardener с именем "Вася" и передаем ему в уход объект TomatoBush.
39. gardener.work() - Садовник работает, вызывая метод grow_all у объекта TomatoBush, переводя томаты на следующую стадию созревания.
40. gardener.harvest() - Садовник собирает урожай, вызывая методы all_are_ripe и give_away_all у объекта TomatoBush. Выводится сообщение в зависимости от того, все ли томаты созрели.
41. По аналогии продолжаются последующие шаги работы садовника и сбора урожая.

## Общий вывод
В данной работе применяются концепции и принципы объектно-ориентированного программирования (ООП). 
ООП — это методология программирования, которая ориентирована на организацию кода вокруг объектов, представляющих реальные сущности, их свойства и взаимодействия.

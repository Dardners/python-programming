# Тема № 11. Итераторы и генераторы

Отчет по Теме № 11 выполнил:

- Голосов Михаил Кириллович
  
- ОЗИВТ-22-1-у
  
| Задание | Лаб_Раб | Сам_раб |
| ------ | ------ | ------ |
| Задание 1 | + | + |
| Задание 2 | + | + |
| Задание 3 | + |   |
| Задание 4 | + |   | 
| Задание 5 | + |   | 

знак "+" - задание выполнено; знак "-" - задание не выполнено;

Работу проверили:

- к.э.н, доцент Панов М.А

# Лабороторная работа№1
### Простой итератор, но у него нет гибкой настройки, например его нельзя развернуть. Он работает просто как next(), но нет prev() 
```python
class SimpleIterator:
    def __init__(self, data):
        # Инициализация итератора с переданными данными и установкой текущего индекса
        self.data = data
        self.index = 0

    def __iter__(self):
        # Возвращает сам объект итератора, поскольку он является итерируемым
        return self

    def __next__(self):
        # Реализация метода next() для получения следующего элемента
        if self.index < len(self.data):
            result = self.data[self.index]
            self.index += 1
            return result
        else:
            # Если достигнут конец данных, вызывается StopIteration
            raise StopIteration("End of iteration")

# Пример использования простого итератора:
if __name__ == '__main__':
    data_list = [1, 2, 3, 4, 5]
    simple_iter = SimpleIterator(data_list)

    for item in simple_iter:
        print(item)
```
### Результат
![Меню](https://github.com/Dardners/python-programming/blob/main/picture/Theme_11-1.png)
## Выводы
1. class SimpleIterator: - Определение класса SimpleIterator, который будет представлять простой итератор.
2. def __init__(self, data): - Метод инициализации итератора, принимает данные и устанавливает текущий индекс.
3. self.data = data - Инициализация атрибута data данными, которые будут использоваться в итераторе.
4. self.index = 0 - Инициализация атрибута index текущим индексом итератора.
5. def __iter__(self): - Метод для поддержки протокола итератора, возвращает сам объект итератора.
6. return self - Возвращение самого объекта итератора.
7. def __next__(self): - Метод для поддержки протокола итератора, реализация получения следующего элемента.
8. if self.index < len(self.data): - Проверка, не достигнут ли конец данных.
9. result = self.data[self.index] - Получение текущего элемента данных.
10. self.index += 1 - Увеличение индекса для перехода к следующему элементу.
11. return result - Возвращение полученного элемента.
12. raise StopIteration("End of iteration") - В случае достижения конца данных вызывается исключение StopIteration.
13. if __name__ == '__main__': - Проверка, является ли скрипт основным (а не импортированным).
14. data_list = [1, 2, 3, 4, 5] - Инициализация списка данных.
15. simple_iter = SimpleIterator(data_list) - Создание объекта простого итератора.
16. for item in simple_iter: - Использование итератора в цикле for.
17. print(item) - Вывод каждого элемента итератора.

# Лабороторная работа№2
### Класс итератор с гибкой настройкой и удобными применением
```python
class FlexibleIterator:
    def __init__(self, start, end, step=1):
        # Инициализация итератора с начальным, конечным значениями и шагом
        self.start = start
        self.end = end
        self.step = step

    def __iter__(self):
        # Возвращает сам объект итератора, так как он является итерируемым
        return self

    def __next__(self):
        # Реализация метода next() для получения следующего элемента
        if self.step > 0 and self.start >= self.end:
            # Если шаг положителен и текущее значение больше или равно конечному значению, вызывается StopIteration
            raise StopIteration("End of iteration")
        elif self.step < 0 and self.start <= self.end:
            # Если шаг отрицателен и текущее значение меньше или равно конечному значению, вызывается StopIteration
            raise StopIteration("End of iteration")
        else:
            result = self.start
            self.start += self.step
            return result

# Пример использования гибкого итератора:
if __name__ == '__main__':
    flexible_iter = FlexibleIterator(start=1, end=10, step=2)

    for item in flexible_iter:
        print(item)
```
### Результат
![Меню](https://github.com/Dardners/python-programming/blob/main/picture/Theme_11-2.png)
## Выводы
1. class FlexibleIterator: - Определение класса FlexibleIterator, который будет представлять гибкий итератор.
2. def __init__(self, start, end, step=1): - Метод инициализации итератора, принимает начальное и конечное значения, а также шаг (по умолчанию 1).
3. self.start = start - Инициализация атрибута start начальным значением.
4. self.end = end - Инициализация атрибута end конечным значением.
5. self.step = step - Инициализация атрибута step значением шага.
6. def __iter__(self): - Метод для поддержки протокола итератора, возвращает сам объект итератора.
7. return self - Возвращение самого объекта итератора.
8. def __next__(self): - Метод для поддержки протокола итератора, реализация получения следующего элемента.
9. if self.step > 0 and self.start >= self.end: - Проверка, если шаг положителен и текущее значение больше или равно конечному значению, вызывается исключение StopIteration.
10. raise StopIteration("End of iteration") - Вызов исключения StopIteration для сигнализации о конце итерации.
11. elif self.step < 0 and self.start <= self.end: - Проверка, если шаг отрицателен и текущее значение меньше или равно конечному значению, вызывается исключение StopIteration.
12. result = self.start - Получение текущего значения.
13. self.start += self.step - Увеличение текущего значения на шаг.
14. return result - Возвращение полученного значения.
15. if __name__ == '__main__': - Проверка, является ли скрипт основным (а не импортированным).
16. flexible_iter = FlexibleIterator(start=1, end=10, step=2) - Создание объекта гибкого итератора с параметрами.
17. for item in flexible_iter: - Использование итератора в цикле for.
18. print(item) - Вывод каждого элемента итератора.

# Лабороторная работа№3
### Генератор списка 
```python
# Генератор списка для создания списка квадратов чисел от 0 до 9
squares = [x**2 for x in range(10)]

# Вывод списка квадратов
print(squares)
```
### Результат
![Меню](https://github.com/Dardners/python-programming/blob/main/picture/Theme_11-3.png)
## Выводы
В данном коде. 
1. squares = [x**2 for x in range(10)] - Генератор списка, который создает список квадратов чисел от 0 до 9.
2. print(squares) - Вывод списка квадратов в консоль.

# Лабороторная работа№4
### Выражения генераторы 
```python
# Выражение-генератор для создания генератора квадратов чисел от 0 до 9
squares_generator = (x**2 for x in range(10))

# Использование генератора в цикле
for square in squares_generator:
    print(square)
```
### Результат
![Меню](https://github.com/Dardners/python-programming/blob/main/picture/Theme_11-4.png)
## Выводы
1. squares_generator = (x**2 for x in range(10)) - Создание выражения-генератора, которое генерирует квадраты чисел от 0 до 9.
2. for square in squares_generator: - Использование генератора в цикле.
3. print(square) - Вывод текущего значения генератора в консоль.

# Лабороторная работа№5
### Такой же счетчик, как и в первом задании, только это генератор и использует yield 
```python
def counter_generator(start, end):
    current = start
    while current <= end:
        yield current
        current += 1

# Пример использования генератора-счетчика:
if __name__ == '__main__':
    my_counter = counter_generator(1, 5)

    for count in my_counter:
        print(count)
```
### Результат
![Меню](https://github.com/Dardners/python-programming/blob/main/picture/Theme_11-5.png)
## Выводы
1. def counter_generator(start, end): - Определение функции генератора counter_generator с параметрами start и end.
2. current = start - Инициализация переменной current начальным значением счетчика.
3. while current <= end: - Запуск цикла, выполняющегося до тех пор, пока текущее значение счетчика меньше или равно конечному значению.
4. yield current - Использование ключевого слова yield для возврата текущего значения счетчика, сохраняя состояние функции.
5. current += 1 - Увеличение текущего значения счетчика на 1.
6. if __name__ == '__main__': - Проверка, является ли скрипт основным (а не импортированным).
7. my_counter = counter_generator(1, 5) - Создание экземпляра генератора-счетчика с начальным значением 1 и конечным значением 5.
8. for count in my_counter: - Использование генератора-счетчика в цикле.
9. print(count) - Вывод текущего значения счетчика в консоль.

# Самостоятельная работа№1
### Вас никак не могут оставить числа Фибоначчи, очень уж они вас заинтересовали. Изучив новые возможности Python вы решили реализовать программу, которая считает числа Фибоначчи при помощи итераторов. Расчет начинается с чисел 1 и 1. Создайте функцию fib(n), генерирующую n чисел Фибоначчи с минимальными затратами ресурсов. Для реализации этой функции потребуется обратиться к инструкции yield (Она не сохраняет в оперативной памяти огромную последовательность, а дает возможность “доставать” промежуточные результаты по одному). Результатом решения задачи будет листинг кода и вывод в консоль с числом Фибоначчи от 200. 
```python
def fib(n):
    a, b = 1, 1
    count = 0

    while count < n:
        yield a
        a, b = b, a + b
        count += 1

# Пример использования функции для вывода числа Фибоначчи от 200:
if __name__ == '__main__':
    fibonacci_sequence = list(fib(200))
    print(f"Fibonacci number at position 200: {fibonacci_sequence[-1]}")
```
### Результат
![Меню](https://github.com/Dardners/python-programming/blob/main/picture/Theme_11-6.png)
## Выводы
1. def fib(n): - Определение функции fib с параметром n, который указывает количество генерируемых чисел Фибоначчи.
2. a, b = 1, 1 - Инициализация переменных a и b начальными значениями чисел Фибоначчи.
3. count = 0 - Инициализация счетчика для отслеживания количества уже сгенерированных чисел.
4. while count < n: - Запуск цикла, выполняющегося, пока не сгенерировано достаточное количество чисел.
5. yield a - Использование ключевого слова yield для возврата текущего значения числа Фибоначчи без сохранения всей последовательности в памяти.
6. a, b = b, a + b - Обновление значений переменных a и b для генерации следующего числа Фибоначчи.
7. count += 1 - Увеличение счетчика сгенерированных чисел.
8. if __name__ == '__main__': - Проверка, является ли скрипт основным (а не импортированным).
9. fibonacci_sequence = list(fib(200)) - Генерация списка из 200 чисел Фибоначчи при помощи вызова функции и преобразования результата в список.
10. print(f"Fibonacci number at position 200: {fibonacci_sequence[-1]}") - Вывод в консоль значения числа Фибоначчи на позиции 200.

# Самостоятельная работа№2
### К коду предыдущей задачи добавьте запоминание каждого числа Фибоначчи в файл “fib.txt”, при этом каждое число должно находиться на отдельной строчке. Результатом выполнения задачи будет листинг кода и скриншот получившегося файла 
```python
def fib(n):
    a, b = 1, 1
    count = 0

    with open('fib.txt', 'w') as file:
        while count < n:
            file.write(str(a) + '\n')  # Запись числа в файл
            yield a
            a, b = b, a + b
            count += 1

# Пример использования функции для вывода числа Фибоначчи от 200:
if __name__ == '__main__':
    fibonacci_sequence = list(fib(200))
    print(f"Fibonacci number at position 200: {fibonacci_sequence[-1]}")
```
### Результат
![Меню](https://github.com/Dardners/python-programming/blob/main/picture/Theme_11-7.png)
## Выводы
1. with open('fib.txt', 'w') as file: - Открытие файла "fib.txt" в режиме записи с использованием контекстного менеджера. Это гарантирует корректное закрытие файла после выполнения блока кода.
2. file.write(str(a) + '\n') - Запись текущего значения числа Фибоначчи в файл, преобразованного в строку. \n добавляет перевод строки для разделения чисел.

## Общий вывод
В этой работе были рассмотрены итераторы и генераторы в Python, которые представляют собой мощные инструменты для обработки и обхода коллекций данных.
Итераторы и генераторы предоставляют эффективные инструменты для работы с данными в Python, снижая нагрузку на память и упрощая код. Их понимание и использование являются важными аспектами для разработчика на Python.
